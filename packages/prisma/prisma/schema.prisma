// ============================================================================
// Skatekrak Prisma Schema
// Migrated from MongoDB/Mongoose models in apps/carrelage
// ============================================================================

generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
}

// ============================================================================
// Enums
// ============================================================================

enum Role {
  USER
  MODERATOR
  ADMIN
}

enum SubscriptionStatus {
  ACTIVE
  EXPIRED
  CANCELLED
  NONE
}

enum DeviceType {
  IOS
  ANDROID
}

enum Stance {
  GOOFY
  REGULAR
}

enum SpotType {
  SHOP
  STREET
  PARK
  DIY
  PRIVATE
}

enum SpotStatus {
  ACTIVE
  WIP
  RIP
}

enum Obstacle {
  STAIRS
  GAP
  STREET_GAP
  LEDGE
  HUBBA
  BENCH
  LOW_TO_HIGH
  MANNY_PAD
  SLAPPY
  POLEJAM
  JERSEY
  DROP
  FLATGROUND
  HANDRAIL
  FLATBAR
  BUMP
  WALLRIDE
  BANK
  TRANNY
  SPINE
  RAMP
  BOWL
  QUARTERPIPE
  FULLPIPE
  DOWNHILL
  HIP
  OTHER
}

enum MediaType {
  IMAGE
  VIDEO
}

enum ClipProvider {
  YOUTUBE
  VIMEO
}

// ============================================================================
// User & Auth
// ============================================================================

/// Core user account. Username was previously used as _id in MongoDB.
model User {
  id                     String             @id @default(uuid())
  username               String             @unique
  email                  String?            @unique
  emailVerified          Boolean            @default(false)
  emailConfirmationToken String?
  welcomeMailSent        Boolean            @default(false)
  password               String? // bcrypt hash
  role                   Role               @default(USER)
  resetPasswordToken     String?
  resetPasswordExpires   DateTime?
  receiveNewsletter      Boolean            @default(false)
  subscriptionStatus     SubscriptionStatus @default(NONE)
  stripeCustomerId       String?
  subscriptionEndAt      DateTime?
  createdAt              DateTime           @default(now())
  updatedAt              DateTime           @updatedAt

  // Relations
  installations Installation[]
  authProvider  AuthProvider?
  profile       Profile?
  tokens        Token[]

  @@index([createdAt])
  @@index([updatedAt])
  @@map("users")
}

/// OAuth / social auth providers. Was embedded in User as `auth` sub-document.
model AuthProvider {
  id                  String    @id @default(uuid())
  userId              String    @unique
  facebookUserId      String? // was auth.facebook.user_id
  facebookAccessToken String? // was auth.facebook.access_token
  facebookExpiresAt   DateTime? // was auth.facebook.expires_at
  appleId             String? // was auth.apple.apple_id

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("auth_providers")
}

/// Push notification device registrations. Was embedded array in User.
model Installation {
  id               String     @id @default(uuid())
  userId           String
  deviceToken      String
  appVersion       Int?
  version          String?
  deviceType       DeviceType
  localeIdentifier String? // format: xx-XX
  timezone         String? // format: Region/City
  badge            Int        @default(0)
  channels         String[]
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("installations")
}

/// Auth tokens for user sessions.
model Token {
  id        String    @id @default(uuid())
  token     String    @unique
  userId    String
  role      String
  expires   DateTime?
  ip        String?
  location  String? // geo-located string from IP
  userAgent String?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt])
  @@map("tokens")
}

// ============================================================================
// Profile
// ============================================================================

/// User profile with social info, stats, and gear. One-to-one with User.
model Profile {
  id                 String   @id @default(uuid())
  userId             String   @unique
  description        String?
  location           String?
  stance             Stance?
  snapchat           String?
  instagram          String?
  website            String?
  sponsors           String[]
  profilePicture     Json? // CloudinaryFile: { publicId, version, url, format, width, height }
  banner             Json? // CloudinaryFile
  followersStat      Json? // Stat: { all, monthly, weekly, daily, createdAt }
  followingStat      Json? // Stat
  spotsFollowingStat Json? // Stat
  mediasStat         Json? // Stat
  clipsStat          Json? // Stat
  tricksDoneStat     Json? // Stat

  // Gear fields (flattened from embedded Gear sub-document)
  gearDeck     String?
  gearTrucks   String?
  gearWheels   String?
  gearBearings String?
  gearGrip     String?
  gearHardware String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user           User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  followers      ProfileFollow[]     @relation("following") // profiles that follow this profile
  following      ProfileFollow[]     @relation("follower") // profiles this profile follows
  spotsFollowing ProfileSpotFollow[]
  rewards        Reward[]

  // Content authored by this profile
  medias    Media[]
  clips     Clip[]
  spots     Spot[]
  spotEdits SpotEdit[]
  comments  Comment[]
  likes     Like[]

  @@index([createdAt])
  @@index([updatedAt])
  @@map("profiles")
}

/// Self-referencing many-to-many join table for profile followers/following.
model ProfileFollow {
  followerId  String
  followingId String
  createdAt   DateTime @default(now())

  // Relations
  follower  Profile @relation("follower", fields: [followerId], references: [id], onDelete: Cascade)
  following Profile @relation("following", fields: [followingId], references: [id], onDelete: Cascade)

  @@id([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
  @@map("profile_follows")
}

/// Join table for profiles following spots.
model ProfileSpotFollow {
  profileId String
  spotId    String
  createdAt DateTime @default(now())

  // Relations
  profile Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)
  spot    Spot    @relation(fields: [spotId], references: [id], onDelete: Cascade)

  @@id([profileId, spotId])
  @@index([profileId])
  @@index([spotId])
  @@map("profile_spot_follows")
}

/// Achievement/badge unlocked by a profile. Was embedded array in Profile.
model Reward {
  id        String   @id @default(uuid())
  profileId String
  type      String // e.g. create_like, receive_like, create_comment, create_spot, etc.
  subtype   String // milestone: "1", "10", "100"
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  profile Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  @@index([profileId])
  @@map("rewards")
}

// ============================================================================
// Spot
// ============================================================================

/// A skate spot location.
model Spot {
  id           String     @id @default(uuid())
  name         String
  streetName   String? // was location.streetName
  streetNumber String? // was location.streetNumber
  city         String? // was location.city
  country      String? // was location.country
  longitude    Float      @default(0) // was geo[0]
  latitude     Float      @default(0) // was geo[1]
  geoHash      String? // ngeohash encoded
  type         SpotType
  status       SpotStatus @default(ACTIVE)
  description  String?
  indoor       Boolean    @default(false)
  openingHours String[]
  phone        String?
  website      String?
  instagram    String?
  snapchat     String?
  facebook     String?
  addedById    String
  coverURL     String?
  tags         String[]
  obstacles    Obstacle[]

  // Stat snapshots (JSON)
  commentsStat   Json? // Stat: { all, monthly, weekly, daily, createdAt }
  mediasStat     Json? // Stat
  clipsStat      Json? // Stat
  tricksDoneStat Json? // Stat

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  addedBy        Profile             @relation(fields: [addedById], references: [id])
  comments       Comment[]
  edits          SpotEdit[]
  medias         Media[]
  clips          Clip[]
  followedBy     ProfileSpotFollow[]
  mergeEditsFrom SpotEdit[]          @relation("mergeTarget")

  @@index([createdAt])
  @@index([updatedAt])
  @@index([type])
  @@index([status])
  @@index([indoor])
  @@index([addedById])
  @@index([geoHash])
  @@index([tags])
  @@index([obstacles])
  @@map("spots")
}

/// A proposed edit to a spot. Was embedded array in Spot.edits.
model SpotEdit {
  id          String      @id @default(uuid())
  spotId      String
  addedById   String
  name        String?
  longitude   Float?
  latitude    Float?
  type        SpotType?
  status      SpotStatus?
  description String?
  indoor      Boolean?
  phone       String?
  website     String?
  instagram   String?
  snapchat    String?
  facebook    String?
  mergeIntoId String? // FK to another Spot this edit proposes merging into
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  // Relations
  spot      Spot    @relation(fields: [spotId], references: [id], onDelete: Cascade)
  addedBy   Profile @relation(fields: [addedById], references: [id])
  mergeInto Spot?   @relation("mergeTarget", fields: [mergeIntoId], references: [id], onDelete: SetNull)

  @@index([spotId])
  @@index([addedById])
  @@map("spot_edits")
}

// ============================================================================
// Media
// ============================================================================

/// A photo or video posted to a spot.
model Media {
  id          String    @id @default(uuid())
  type        MediaType
  caption     String? // was _caption (usertag placeholders resolved at app level)
  spotId      String?
  addedById   String
  image       Json? // CloudinaryFile: { publicId, version, url, format, width, height }
  video       Json? // CloudinaryFile
  staffPicked Boolean   @default(false)
  releaseDate DateTime?
  hashtags    String[]
  usertags    String[]
  trickDone   Json? // TrickDone snapshot: { trick, points, terrain, stance, ... }

  // Stat snapshots (JSON)
  likesStat    Json? // Stat: { all, monthly, weekly, daily, createdAt }
  commentsStat Json? // Stat

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  spot    Spot?   @relation(fields: [spotId], references: [id], onDelete: SetNull)
  addedBy Profile @relation(fields: [addedById], references: [id])

  comments Comment[]
  likes    Like[]

  @@index([createdAt])
  @@index([updatedAt])
  @@index([type])
  @@index([spotId])
  @@index([addedById])
  @@index([staffPicked])
  @@index([releaseDate])
  @@index([hashtags])
  @@map("media")
}

// ============================================================================
// Clip
// ============================================================================

/// A video clip (YouTube/Vimeo) linked to a spot.
model Clip {
  id           String       @id @default(uuid())
  title        String
  description  String?
  provider     ClipProvider
  videoURL     String
  thumbnailURL String
  spotId       String?
  addedById    String

  // Stat snapshots (JSON)
  likesStat    Json? // Stat: { all, monthly, weekly, daily, createdAt }
  commentsStat Json? // Stat

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  spot    Spot?   @relation(fields: [spotId], references: [id], onDelete: SetNull)
  addedBy Profile @relation(fields: [addedById], references: [id])

  comments Comment[]
  likes    Like[]

  @@index([createdAt])
  @@index([updatedAt])
  @@index([provider])
  @@index([spotId])
  @@index([addedById])
  @@map("clips")
}

// ============================================================================
// Comment & Like (extracted from embedded sub-documents)
// ============================================================================

/// A comment on a Spot, Media, or Clip. Polymorphic via nullable FKs.
/// Exactly one of spotId, mediaId, or clipId should be set.
model Comment {
  id        String   @id @default(uuid())
  content   String // was _content (usertag placeholders resolved at app level)
  addedById String
  spotId    String?
  mediaId   String?
  clipId    String?
  hashtags  String[]
  usertags  String[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  addedBy Profile @relation(fields: [addedById], references: [id])
  spot    Spot?   @relation(fields: [spotId], references: [id], onDelete: Cascade)
  media   Media?  @relation(fields: [mediaId], references: [id], onDelete: Cascade)
  clip    Clip?   @relation(fields: [clipId], references: [id], onDelete: Cascade)
  likes   Like[]

  @@index([addedById])
  @@index([spotId])
  @@index([mediaId])
  @@index([clipId])
  @@index([createdAt])
  @@map("comments")
}

/// A like on a Media, Clip, or Comment. Polymorphic via nullable FKs.
/// Exactly one of mediaId, clipId, or commentId should be set.
model Like {
  id        String   @id @default(uuid())
  addedById String
  mediaId   String?
  clipId    String?
  commentId String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  addedBy Profile  @relation(fields: [addedById], references: [id])
  media   Media?   @relation(fields: [mediaId], references: [id], onDelete: Cascade)
  clip    Clip?    @relation(fields: [clipId], references: [id], onDelete: Cascade)
  comment Comment? @relation(fields: [commentId], references: [id], onDelete: Cascade)

  // Prevent double-liking the same entity
  @@unique([addedById, mediaId])
  @@unique([addedById, clipId])
  @@unique([addedById, commentId])
  @@index([addedById])
  @@index([mediaId])
  @@index([clipId])
  @@index([commentId])
  @@map("likes")
}
